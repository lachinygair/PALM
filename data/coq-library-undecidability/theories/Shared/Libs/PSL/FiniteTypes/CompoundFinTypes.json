{"code": ["From Undecidability.Shared.Libs.PSL Require Import FinTypes.", "Lemma ProdCount (T1 T2: eqType) (A: list T1) (B: list T2) (a:T1) (b:T2) : count (prodLists A B) (a,b) = count A a * count B b .", "Proof.", "induction A.", "-", "reflexivity.", "-", "cbn.", "rewrite <- countSplit.", "decide (a = a0) as [E | E].", "+", "cbn.", "f_equal.", "subst a0.", "apply countMap.", "eauto.", "+", "rewrite <- plus_O_n.", "f_equal.", "now apply countMapZero.", "eauto.", "Qed.", "Lemma prod_enum_ok (T1 T2: finType) (x: T1 * T2): count (prodLists (elem T1) (elem T2)) x = 1.", "Proof.", "destruct x as [x y].", "rewrite ProdCount.", "unfold elem.", "now repeat rewrite enum_ok.", "Qed.", "Instance finTypeC_Prod (F1 F2: finType) : finTypeC (EqType (F1 * F2)).", "Proof.", "econstructor.", "apply prod_enum_ok.", "Defined.", "Lemma SomeElement (X: eqType) (A: list X) x: count (toOptionList A) (Some x) = count A x .", "Proof.", "unfold toOptionList.", "simpl.", "dec; try congruence.", "induction A.", "+", "tauto.", "+", "simpl.", "dec; congruence.", "Qed.", "Lemma NoneElement (X: eqType) (A: list X) : count (toOptionList A) None = 1.", "Proof.", "unfold toOptionList.", "simpl.", "dec; try congruence.", "f_equal.", "induction A.", "-", "reflexivity.", "-", "simpl; dec; congruence.", "Qed.", "Lemma option_enum_ok (T: finType) x : count (toOptionList (elem T)) x = 1.", "Proof.", "destruct x.", "+", "rewrite SomeElement.", "apply enum_ok.", "+", "apply NoneElement.", "Qed.", "Instance finTypeC_Option(F: finType): finTypeC (EqType (option F)).", "Proof.", "eapply FinTypeC.", "apply option_enum_ok.", "Defined.", "Lemma proveOne m n: m = 1 /\\ n = 0 \\/ n = 1 /\\ m = 0 -> m + n = 1.", "Proof.", "lia.", "Qed.", "Lemma sum_enum_ok (X: finType) (Y: finType) x : count (toSumList1 Y (elem X) ++ toSumList2 X (elem Y)) x = 1.", "Proof.", "rewrite <- countSplit.", "apply proveOne.", "destruct x.", "-", "left.", "split; cbn.", "+", "rewrite toSumList1_count.", "apply enum_ok.", "+", "apply toSumList2_missing.", "-", "right.", "split; cbn.", "+", "rewrite toSumList2_count.", "apply enum_ok.", "+", "apply toSumList1_missing.", "Qed.", "Instance finTypeC_sum (X Y: finType) : finTypeC (EqType ( X + Y)).", "Proof.", "eapply FinTypeC.", "apply sum_enum_ok.", "Defined.", "Hint Extern 4 (finTypeC (EqType (_ * _))) => eapply finTypeC_Prod : typeclass_instances.", "Hint Extern 4 (finTypeC (EqType (_ + _))) => eapply finTypeC_sum : typeclass_instances.", "Hint Extern 4 (finTypeC (EqType (option _))) => eapply finTypeC_Option : typeclass_instances."], "theorems": [{"name": "ProdCount", "kind": "Lemma", "begin": 1, "end": 21}, {"name": "prod_enum_ok", "kind": "Lemma", "begin": 22, "end": 28}, {"name": "finTypeC_Prod", "kind": "Instance", "begin": 29, "end": 33}, {"name": "SomeElement", "kind": "Lemma", "begin": 34, "end": 45}, {"name": "NoneElement", "kind": "Lemma", "begin": 46, "end": 57}, {"name": "option_enum_ok", "kind": "Lemma", "begin": 58, "end": 66}, {"name": "finTypeC_Option", "kind": "Instance", "begin": 67, "end": 71}, {"name": "proveOne", "kind": "Lemma", "begin": 72, "end": 75}, {"name": "sum_enum_ok", "kind": "Lemma", "begin": 76, "end": 97}, {"name": "finTypeC_sum", "kind": "Instance", "begin": 98, "end": 102}]}