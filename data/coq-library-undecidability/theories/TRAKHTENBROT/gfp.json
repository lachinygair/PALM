{"code": ["Require Import List Arith Nat Lia Relations.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list finite php.", "From Undecidability.TRAKHTENBROT Require Import notations.", "Set Implicit Arguments.", "Section gfp.", "Variable (M : Type).", "Implicit Type (R T : M -> M -> Prop).", "Notation \"R \u2286 T\" := (forall x y, R x y -> T x y).", "Notation \"R 'o' T\" := (fun x z => exists y, R x y /\\ T y z) (at level 58).", "Let incl_trans R S T : R \u2286 S -> S \u2286 T -> R \u2286 T.", "Proof.", "firstorder.", "Qed.", "Let comp_mono R R' T T' : R \u2286 R' -> T \u2286 T' -> R o T \u2286 R' o T'.", "Proof.", "firstorder.", "Qed.", "Variable (F : (M -> M -> Prop) -> M -> M -> Prop).", "Hypothesis (HF0 : forall R T, R \u2286 T -> F R \u2286 F T).", "Let sym R := fun x y => R y x.", "Let i := iter F (fun _ _ => True).", "Let iS n : i (S n) = F (i n).", "Proof.", "apply iter_S.", "Qed.", "Let i0 : i 0 = fun _ _ => True.", "Proof.", "auto.", "Qed.", "Let i_S n : i (S n) \u2286 i n.", "Proof.", "unfold i.", "induction n as [ | n IHn ].", "+", "simpl; auto.", "+", "intros ? ?.", "rewrite iter_S with (n := n), iter_S.", "apply HF0, IHn.", "Qed.", "Let i_decr n m : n <= m -> i m \u2286 i n.", "Proof.", "induction 1; auto.", "Qed.", "Definition gfp x y := forall n, i n x y.", "Notation I := (@eq M).", "Hypothesis HF1 : I \u2286 F I.", "Let i_refl n : I \u2286 i n.", "Proof.", "induction n as [ | n IHn ].", "+", "rewrite i0; auto.", "+", "rewrite iS.", "apply incl_trans with (1 := HF1), HF0, IHn.", "Qed.", "Let gfp_refl : I \u2286 gfp.", "Proof.", "intros ? ? [] ?; apply i_refl; auto.", "Qed.", "Hypothesis HF2 : forall R, sym (F R) \u2286 F (sym R).", "Let i_sym n : sym (i n) \u2286 i n.", "Proof.", "induction n as [ | n IHn ].", "+", "intros ? ?; rewrite i0; simpl; auto.", "+", "rewrite iS; apply incl_trans with (2 := HF0 _ IHn), HF2.", "Qed.", "Let gfp_sym : sym gfp \u2286 gfp.", "Proof.", "intros ? ? H ?; apply i_sym, H.", "Qed.", "Hypothesis HF3 : forall R, F R o F R \u2286 F (R o R).", "Let i_trans n : i n o i n \u2286 i n.", "Proof.", "induction n as [ | n IHn ].", "+", "rewrite i0; auto.", "+", "rewrite iS; apply incl_trans with (1 := @HF3 _), HF0, IHn.", "Qed.", "Let gfp_trans : gfp o gfp \u2286 gfp.", "Proof.", "intros ? ? H ?; apply i_trans.", "revert H; apply comp_mono; auto.", "Qed.", "Fact gfp_equiv : equiv _ gfp.", "Proof.", "msplit 2.", "+", "intro; apply gfp_refl; auto.", "+", "intros ? y ? ? ?; apply gfp_trans; exists y; auto.", "+", "intros ? ?; apply gfp_sym.", "Qed.", "Fact gfp_greatest R : R \u2286 F R -> R \u2286 gfp.", "Proof.", "intros HR x y H n; revert x y H.", "induction n as [ | n IHn ].", "+", "now auto.", "+", "apply incl_trans with (1 := HR).", "rewrite iS; apply HF0; auto.", "Qed.", "Let gfp_fix1 : F gfp \u2286 gfp.", "Proof.", "intros ? ? H ?.", "apply i_S; rewrite iS.", "revert H; apply HF0; auto.", "Qed.", "Definition gfp_continuous := forall (s : nat -> M -> M -> Prop), (forall n m, n <= m -> s m \u2286 s n) -> (fun x y => forall n, F (s n) x y) \u2286 F (fun x y => forall n, s n x y).", "Variable HF4 : gfp_continuous.", "Let gfp_fix0 : gfp \u2286 F gfp.", "Proof.", "intros ? ? H.", "apply HF4; auto.", "intro; rewrite <- iS; apply H.", "Qed.", "Fact gfp_fix x y : F gfp x y <-> gfp x y.", "Proof.", "split; auto.", "Qed.", "Let dec R := forall x y, { R x y } + { ~ R x y }.", "Variable HF5 : forall R, dec R -> dec (F R).", "Let i_dec n : dec (i n).", "Proof.", "induction n as [ | n IHn ].", "+", "rewrite i0; left; auto.", "+", "rewrite iS; apply HF5; auto.", "Qed.", "Let i_dup n m : n < m -> i n \u2286 i m -> forall k, n <= k -> forall x y, gfp x y <-> i k x y.", "Proof.", "intros H1 H2.", "generalize (i_decr H1) (i_S n); rewrite iS; intros H3 H4.", "generalize (incl_trans _ _ _ H2 H3); intros H5.", "assert (forall p, i n \u2286 i (p+n)) as H6.", "{", "induction p as [ | p IHp ]; auto.", "simpl plus; rewrite iS.", "apply incl_trans with (1 := H5), HF0; auto.", "}", "intros k Hk x y; split; auto.", "intros H a.", "destruct (le_lt_dec a k).", "+", "revert H; apply i_decr; auto.", "+", "replace a with (a-n+n) by lia.", "apply H6.", "revert H; apply i_decr; auto.", "Qed.", "Let gfp_reached b : (exists n m, n < m <= b /\\ i n \u2286 i m) -> (forall x y, gfp x y <-> i b x y).", "Proof.", "intros (n & m & H1 & H2).", "apply i_dup with (2 := H2); auto; try lia.", "Qed.", "Variable HF6 : finite_t M.", "Theorem gfp_finite_t : { n | forall x y, gfp x y <-> i n x y }.", "Proof.", "destruct finite_t_weak_dec_rels with (1 := HF6) as (mR & HmR).", "exists (S (length mR)).", "set (l := map i (list_an 0 (S (length mR)))).", "apply (@gfp_reached (S (length mR))).", "destruct php_upto with (R := fun R T => forall x y, R x y <-> T x y) (l := l) (m := mR) as (a & R & b & T & c & H1 & H2).", "+", "intros R S H ? ?; rewrite H; tauto.", "+", "intros R S T H1 H2 ? ?; rewrite H1, H2; tauto.", "+", "intros R HR.", "unfold l in HR; apply in_map_iff in HR.", "destruct HR as (n & <- & _).", "destruct (HmR (i n)) as (T & H1 & H2).", "*", "intros x y; destruct (i_dec n x y); tauto.", "*", "exists T; auto.", "+", "unfold l; rewrite map_length, list_an_length; auto.", "+", "unfold l in H1; apply map_duplicate_inv in H1.", "destruct H1 as (a' & n & b' & m & c' & H1 & H3 & H4 & H5 & H6 & H7).", "exists n, m; rewrite <- H3, <- H5; split; try (intros ? ?; apply H2).", "apply list_an_duplicate_inv in H7; lia.", "Qed.", "Theorem gfp_decidable : dec gfp.", "Proof.", "destruct gfp_finite_t as (n & Hn).", "intros x y; destruct (i_dec n x y); [ left | right ]; rewrite Hn; tauto.", "Qed.", "End gfp."], "theorems": [{"name": "incl_trans", "kind": "Let", "begin": 9, "end": 12}, {"name": "comp_mono", "kind": "Let", "begin": 13, "end": 16}, {"name": "iS", "kind": "Let", "begin": 21, "end": 24}, {"name": "i0", "kind": "Let", "begin": 25, "end": 28}, {"name": "i_S", "kind": "Let", "begin": 29, "end": 39}, {"name": "i_decr", "kind": "Let", "begin": 40, "end": 43}, {"name": "i_refl", "kind": "Let", "begin": 47, "end": 55}, {"name": "gfp_refl", "kind": "Let", "begin": 56, "end": 59}, {"name": "i_sym", "kind": "Let", "begin": 61, "end": 68}, {"name": "gfp_sym", "kind": "Let", "begin": 69, "end": 72}, {"name": "i_trans", "kind": "Let", "begin": 74, "end": 81}, {"name": "gfp_trans", "kind": "Let", "begin": 82, "end": 86}, {"name": "gfp_equiv", "kind": "Fact", "begin": 87, "end": 96}, {"name": "gfp_greatest", "kind": "Fact", "begin": 97, "end": 106}, {"name": "gfp_fix1", "kind": "Let", "begin": 107, "end": 112}, {"name": "gfp_fix0", "kind": "Let", "begin": 115, "end": 120}, {"name": "gfp_fix", "kind": "Fact", "begin": 121, "end": 124}, {"name": "i_dec", "kind": "Let", "begin": 127, "end": 134}, {"name": "i_dup", "kind": "Let", "begin": 135, "end": 155}, {"name": "gfp_reached", "kind": "Let", "begin": 156, "end": 160}, {"name": "gfp_finite_t", "kind": "Theorem", "begin": 162, "end": 189}, {"name": "gfp_decidable", "kind": "Theorem", "begin": 190, "end": 194}]}