{"code": ["Require Export Functions.", "Require Export Reductions.", "Set Implicit Arguments.", "Section Global.", "Variable A: Type.", "Section Sim.", "Variables X Y: Type.", "Variable TX: reduction_t A X.", "Variable TY: reduction_t A Y.", "Definition evolve_1 l R S := diagram (TX l) R (Weak TY l) S.", "Definition evolve_t R S := evolve_1 (T A) R S.", "Definition evolve_a R S := forall a, evolve_1 (L a) R S .", "Definition evolve R S := forall l, evolve_1 l R S.", "Definition simulation_t R := evolve_t R R.", "Definition simulation R := evolve R R.", "Definition expansion1 R := diagram_r TX R (EWeak TY) R.", "Definition wexpansion1 R := diagram_r TX R (REWeak TY) R.", "Variable F: function X Y.", "Record monotonic: Prop := mkmon { mon_m:> increasing F; mon_t: forall R S, evolve_t R S -> incl R S -> evolve_t (F R) (F S); mon_a: forall R S, evolve R S -> incl R S -> evolve_a (F R) (F S) }.", "Record wmonotonic: Prop := mkwmon { wmon_m:> increasing F; wmon_t: forall R, simulation_t R -> simulation_t (F R); wmon_a: forall R S, simulation_t R -> simulation_t S -> evolve_a R S -> incl R S -> evolve_a (F R) (F S) }.", "Variable B: relation X.", "Record controlled: Prop := mkctrl { ctrl_t: forall R, evolve_t R (comp (star B) R) -> simulation_t (comp (star B) R); ctrl_a: forall R S, evolve_t R (comp (star B) R) -> simulation_t S -> evolve_a R S -> incl R S -> evolve_a (comp (star B) R) (comp (star B) S) }.", "Lemma weak_strong_t: forall R, simulation_t R -> diagram (Weak TX (T A)) R (Weak TY (T A)) R.", "Proof.", "intros R HR; simpl; apply diagram_reverse; apply diagram_star; apply diagram_reverse; exact HR.", "Qed.", "Lemma weak_strong: forall R, simulation R -> diagram_r (Weak TX) R (Weak TY) R.", "Proof.", "intros R HR; generalize (weak_strong_t (HR (T A))); intros Ht l; destruct l as [ | a ]; auto.", "intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ]; destruct Hx1x' as [ x2 Hx1x2 Hx2x' ].", "destruct (Ht _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].", "destruct (HR _ _ _ _ Hx1x2 x1Ry1) as [ y2 Hy1y2 x2Ry2 ].", "destruct (Ht _ _ _ Hx2x' x2Ry2) as [ y' Hy2y' x'Ry' ].", "exists y'; auto.", "apply taus_weak with y1; auto.", "apply weak_taus with y2; auto.", "Qed.", "Lemma union2_evolve: forall l R R' S, evolve_1 l R S -> evolve_1 l R' S -> evolve_1 l (union2 R R') S.", "Proof.", "intros l R R' S HR HR' x x' y Hxx' xRy; destruct xRy as [ xRy | xRy ].", "destruct (HR _ _ _ Hxx' xRy) as [ y' ]; exists y'; auto.", "destruct (HR' _ _ _ Hxx' xRy) as [ y' ]; exists y'; auto.", "Qed.", "Lemma union2_evolve_left: forall l R S S', evolve_1 l R S -> evolve_1 l R (union2 S S').", "Proof.", "intros l R S S' H x x' y Hxx' xRy; destruct (H _ _ _ Hxx' xRy) as [ y' ]; exists y'; auto; left; auto.", "Qed.", "Lemma union2_evolve_right: forall l R S S', evolve_1 l R S' -> evolve_1 l R (union2 S S').", "Proof.", "intros l R S S' H x x' y Hxx' xRy; destruct (H _ _ _ Hxx' xRy) as [ y' ]; exists y'; auto; right; auto.", "Qed.", "Lemma union_evolve: forall l I R S, (forall i:I, evolve_1 l (R i) S) -> evolve_1 l (union R) S.", "Proof.", "intros l I R S H x x' y Hxx' xRy; destruct xRy as [ i xRy ].", "destruct (H i _ _ _ Hxx' xRy) as [ y' ]; exists y'; auto.", "Qed.", "Lemma evolve_union: forall l J R S, (exists j:J, evolve_1 l R (S j)) -> evolve_1 l R (union S).", "Proof.", "intros l J R S H x x' y Hxx' xRy.", "destruct H as [ j Hj ]; destruct (Hj _ _ _ Hxx' xRy) as [ y' ].", "exists y'; auto; exists j; auto.", "Qed.", "Lemma incl_evolve: forall l R R' S, incl R R' -> evolve_1 l R' S -> evolve_1 l R S.", "Proof.", "intros l R R' S HRR' HR'S x x' y Hxx' xRy.", "destruct (HR'S _ _ _ Hxx' (HRR' _ _ xRy)) as [ y' ]; exists y'; auto.", "Qed.", "Lemma evolve_incl: forall l S R S', incl S S' -> evolve_1 l R S -> evolve_1 l R S'.", "Proof.", "intros l S R S' HSS' HRS x x' y Hxx' xRy.", "destruct (HRS _ _ _ Hxx' xRy) as [ y' ]; exists y'; auto.", "Qed.", "Lemma simulation_eeq: forall R S, eeq R S -> simulation R -> simulation S.", "Proof.", "intros R S HRS H l.", "apply evolve_incl with R.", "apply (proj1 HRS).", "apply incl_evolve with R.", "apply (proj2 HRS).", "apply H.", "Qed.", "Lemma simulation_t_eeq: forall R S, eeq R S -> simulation_t R -> simulation_t S.", "Proof.", "intros R S HRS H; unfold simulation_t, evolve_t.", "apply evolve_incl with R.", "apply (proj1 HRS).", "apply incl_evolve with R.", "apply (proj2 HRS).", "apply H.", "Qed.", "End Sim.", "Section Bi.", "Variables X Y: Type.", "Variable TX: reduction_t A X.", "Variable TY: reduction_t A Y.", "Definition bisimulation R := simulation TX TY R /\\ simulation TY TX (trans R).", "Definition expansion R := expansion1 TX TY R /\\ simulation TY TX (trans R).", "Definition wexpansion R := wexpansion1 TX TY R /\\ simulation TY TX (trans R).", "Definition bisim := union_st bisimulation.", "Definition expand := union_st expansion.", "Definition wexpand := union_st wexpansion.", "Lemma bisimulation_bisim: bisimulation bisim.", "Proof.", "split; intros l x x' y Hxx' xRy; destruct xRy as [ R HR xRy ]; [ destruct (proj1 HR _ _ _ _ Hxx' xRy) as [ y' ] | destruct (proj2 HR _ _ _ _ Hxx' xRy) as [ y' ] ]; exists y'; auto; exists R; auto.", "Qed.", "Lemma expansion_expand: expansion expand.", "Proof.", "split; intros l x x' y Hxx' xRy; destruct xRy as [ R HR xRy ]; [ destruct (proj1 HR _ _ _ _ Hxx' xRy) as [ y' ] | destruct (proj2 HR _ _ _ _ Hxx' xRy) as [ y' ] ]; exists y'; auto; exists R; auto.", "Qed.", "Lemma wexpansion_wexpand: wexpansion wexpand.", "Proof.", "split; intros l x x' y Hxx' xRy; destruct xRy as [ R HR xRy ]; [ destruct (proj1 HR _ _ _ _ Hxx' xRy) as [ y' ] | destruct (proj2 HR _ _ _ _ Hxx' xRy) as [ y' ] ]; exists y'; auto; exists R; auto.", "Qed.", "Lemma expand_wexpand: incl expand wexpand.", "Proof.", "intros P Q H; destruct H as [ R H H' ]; exists R; auto; split.", "intros l x x' y Hxx' xRy; destruct (proj1 H _ _ _ _ Hxx' xRy) as [ y' Hyy' x'Ry' ]; exists y'; auto.", "destruct l; simpl in Hyy'; intuition; exists y'; auto.", "exact (proj2 H).", "Qed.", "Lemma wexpand_bisim: incl wexpand bisim.", "Proof.", "intros P Q H; destruct H as [ R H H' ]; exists R; auto; split.", "intros l x x' y Hxx' xRy; destruct (proj1 H _ _ _ _ Hxx' xRy) as [ y' Hyy' x'Ry' ]; exists y'; auto.", "destruct l; simpl in Hyy'.", "celim Hyy'; intro Hyy'; try destruct Hyy'; auto.", "exists y; auto.", "exact (proj2 H).", "Qed.", "End Bi.", "Section Composition.", "Variables X Y Z: Type.", "Variable TX: reduction_t A X.", "Variable TY: reduction_t A Y.", "Variable TZ: reduction_t A Z.", "Variable R: relation2 X Y.", "Variable S: relation2 Y Z.", "Lemma simulation_comp: simulation TX TY R -> simulation TY TZ S -> simulation TX TZ (comp R S).", "Proof.", "intros HR HS l x x' y Hxx' xRy; destruct xRy as [ t xRt tRy ].", "destruct (HR _ _ _ _ Hxx' xRt) as [ t' Htt' x'Rt' ].", "destruct (weak_strong HS _ _ _ _ Htt' tRy) as [ y' Hyy' t'Ry' ].", "exists y'; auto; exists t'; auto.", "Qed.", "Lemma expansion1_comp: expansion1 TX TY R -> expansion1 TY TZ S -> expansion1 TX TZ (comp R S).", "Proof.", "intros HR HS l x x' y Hxx' xRy; destruct xRy as [ t xRt tRy ].", "destruct (HR _ _ _ _ Hxx' xRt) as [ t' Htt' x'Rt' ]; destruct l.", "celim Htt'; intro Htt'.", "destruct Htt'; exists y; [ left | exists t ]; auto.", "destruct (HS _ _ _ _ Htt' tRy) as [ y' Hyy' t'Ry' ]; exists y'; auto; exists t'; auto.", "destruct (HS _ _ _ _ Htt' tRy) as [ y' Hyy' t'Ry' ]; exists y'; auto; exists t'; auto.", "Qed.", "Let wexpansion1_t: wexpansion1 TY TZ S -> forall x x' y, star (TY (T _)) x x' -> S x y -> exists2 y', star (TZ (T _)) y y' & S x' y'.", "Proof.", "intros H x x' y Hxx'; cgen y; induction Hxx' as [ x | x1 x x' Hxx1 Hx1x' IH ]; intros y xRy.", "exists y; auto.", "destruct (H _ _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].", "destruct (IH _ x1Ry1) as [ y' Hy1y' x'Ry' ].", "exists y'; auto.", "celim Hyy1; intro Hyy1.", "destruct Hyy1; auto.", "apply S_star with y1; auto.", "Qed.", "Lemma wexpansion1_comp: wexpansion1 TX TY R -> wexpansion1 TY TZ S -> wexpansion1 TX TZ (comp R S).", "Proof.", "intros HR HS l x x' y Hxx' xRy; destruct xRy as [ t xRt tRy ].", "destruct (HR _ _ _ _ Hxx' xRt) as [ t' Htt' x'Rt' ]; destruct l.", "celim Htt'; intro Htt'.", "destruct Htt'; exists y; [ left | exists t ]; auto.", "destruct (HS _ _ _ _ Htt' tRy) as [ y' Hyy' t'Ry' ]; exists y'; auto; exists t'; auto.", "destruct Htt' as [ t1 Htt1 Ht1t' ].", "destruct (HS _ _ _ _ Htt1 tRy) as [ y1 Hyy1 t1Ry1 ].", "destruct (wexpansion1_t HS Ht1t' t1Ry1) as [ y' Hy1y' t'Ry' ].", "exists y'.", "destruct Hyy1 as [ y2 ]; exists y2; auto; apply star_trans with y1; auto.", "exists t'; auto.", "Qed.", "End Composition.", "Section BiComposition.", "Variables X Y Z: Type.", "Variable TX: reduction_t A X.", "Variable TY: reduction_t A Y.", "Variable TZ: reduction_t A Z.", "Variable R: relation2 X Y.", "Variable S: relation2 Y Z.", "Lemma bisimulation_comp: bisimulation TX TY R -> bisimulation TY TZ S -> bisimulation TX TZ (comp R S).", "Proof.", "unfold bisimulation; intros HR HS; split.", "apply simulation_comp with TY; intuition.", "eapply simulation_eeq; try (apply eeq_sym; apply inv_comp).", "apply simulation_comp with TY; intuition.", "Qed.", "Lemma expansion_comp: expansion TX TY R -> expansion TY TZ S -> expansion TX TZ (comp R S).", "Proof.", "unfold expansion; intros HR HS; split.", "apply expansion1_comp with TY; intuition.", "eapply simulation_eeq; try (apply eeq_sym; apply inv_comp).", "apply simulation_comp with TY; intuition.", "Qed.", "Lemma wexpansion_comp: wexpansion TX TY R -> wexpansion TY TZ S -> wexpansion TX TZ (comp R S).", "Proof.", "unfold wexpansion; intros HR HS; split.", "apply wexpansion1_comp with TY; intuition.", "eapply simulation_eeq; try (apply eeq_sym; apply inv_comp).", "apply simulation_comp with TY; intuition.", "Qed.", "End BiComposition.", "Section Properties.", "Variable X: Type.", "Variable TX: reduction_t A X.", "Lemma bisim_sym: symmetric (bisim TX TX).", "Proof.", "intros x y H; destruct H as [ R HR H ].", "exists (trans R); auto.", "celim HR; intro HR; split; auto.", "Qed.", "Lemma bisim_refl: reflexive (bisim TX TX).", "Proof.", "intro u; exists (eq (A:=X)); auto.", "split; intros l x x' y Hxx' xRy; exists x'; destruct xRy; auto.", "Qed.", "Lemma bisim_trans: transitive (bisim TX TX).", "Proof.", "intros y x z XY YZ.", "destruct XY as [ R HR XY ].", "destruct YZ as [ S HS YZ ].", "exists (comp R S).", "apply bisimulation_comp with TX; auto.", "exists y; auto.", "Qed.", "Definition bicontrolled R := controlled TX TX R /\\ incl R (bisim TX TX).", "Lemma expand_refl: reflexive (expand TX TX).", "Proof.", "intro u; exists (eq (A:=X)); auto.", "split; intros l x x' y Hxx' xRy; exists x'; destruct xRy; auto.", "destruct l; auto; right; auto.", "Qed.", "Lemma expand_trans: transitive (expand TX TX).", "Proof.", "intros y x z XY YZ.", "destruct XY as [ R HR XY ].", "destruct YZ as [ S HS YZ ].", "exists (comp R S).", "apply expansion_comp with TX; auto.", "exists y; auto.", "Qed.", "Lemma wexpand_refl: reflexive (wexpand TX TX).", "Proof.", "intro u; exists (eq (A:=X)); auto.", "split; intros l x x' y Hxx' xRy; exists x'; destruct xRy; auto.", "destruct l; [ right | exists x' ]; auto.", "Qed.", "Lemma wexpand_trans: transitive (wexpand TX TX).", "Proof.", "intros y x z XY YZ.", "destruct XY as [ R HR XY ].", "destruct YZ as [ S HS YZ ].", "exists (comp R S).", "apply wexpansion_comp with TX; auto.", "exists y; auto.", "Qed.", "End Properties.", "End Global.", "Ltac union_evolve n := unfold UIter, simulation_t, evolve_t; apply union_evolve; intro n; apply evolve_union."], "theorems": [{"name": "weak_strong_t", "kind": "Lemma", "begin": 22, "end": 25}, {"name": "weak_strong", "kind": "Lemma", "begin": 26, "end": 36}, {"name": "union2_evolve", "kind": "Lemma", "begin": 37, "end": 42}, {"name": "union2_evolve_left", "kind": "Lemma", "begin": 43, "end": 46}, {"name": "union2_evolve_right", "kind": "Lemma", "begin": 47, "end": 50}, {"name": "union_evolve", "kind": "Lemma", "begin": 51, "end": 55}, {"name": "evolve_union", "kind": "Lemma", "begin": 56, "end": 61}, {"name": "incl_evolve", "kind": "Lemma", "begin": 62, "end": 66}, {"name": "evolve_incl", "kind": "Lemma", "begin": 67, "end": 71}, {"name": "simulation_eeq", "kind": "Lemma", "begin": 72, "end": 80}, {"name": "simulation_t_eeq", "kind": "Lemma", "begin": 81, "end": 89}, {"name": "bisimulation_bisim", "kind": "Lemma", "begin": 101, "end": 104}, {"name": "expansion_expand", "kind": "Lemma", "begin": 105, "end": 108}, {"name": "wexpansion_wexpand", "kind": "Lemma", "begin": 109, "end": 112}, {"name": "expand_wexpand", "kind": "Lemma", "begin": 113, "end": 119}, {"name": "wexpand_bisim", "kind": "Lemma", "begin": 120, "end": 128}, {"name": "simulation_comp", "kind": "Lemma", "begin": 137, "end": 143}, {"name": "expansion1_comp", "kind": "Lemma", "begin": 144, "end": 152}, {"name": "wexpansion1_t", "kind": "Let", "begin": 153, "end": 163}, {"name": "wexpansion1_comp", "kind": "Lemma", "begin": 164, "end": 177}, {"name": "bisimulation_comp", "kind": "Lemma", "begin": 186, "end": 192}, {"name": "expansion_comp", "kind": "Lemma", "begin": 193, "end": 199}, {"name": "wexpansion_comp", "kind": "Lemma", "begin": 200, "end": 206}, {"name": "bisim_sym", "kind": "Lemma", "begin": 211, "end": 216}, {"name": "bisim_refl", "kind": "Lemma", "begin": 217, "end": 221}, {"name": "bisim_trans", "kind": "Lemma", "begin": 222, "end": 230}, {"name": "expand_refl", "kind": "Lemma", "begin": 232, "end": 237}, {"name": "expand_trans", "kind": "Lemma", "begin": 238, "end": 246}, {"name": "wexpand_refl", "kind": "Lemma", "begin": 247, "end": 252}, {"name": "wexpand_trans", "kind": "Lemma", "begin": 253, "end": 261}]}