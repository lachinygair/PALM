{"code": ["Require Export Lci.", "Require Export misc.", "Require Export Arith.", "Require Export Nat_complements.", "Require Export groups.", "Require Export rings.", "Require Export Zbase.", "Require Export Z_succ_pred.", "Require Export Zadd.", "Fixpoint multpos (x2 : Z) (n : nat) {struct n} : Z := match n with | O => x2 | S n0 => addZ (multpos x2 n0) x2 end.", "Fixpoint multneg (x2 : Z) (n : nat) {struct n} : Z := match n with | O => oppZ x2 | S n0 => addZ (multneg x2 n0) (oppZ x2) end.", "Definition multZ (x1 x2 : Z) := match x1 with | OZ => OZ | pos n => multpos x2 n | neg n => multneg x2 n end.", "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.", "Proof.", "auto.", "Qed.", "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.", "Proof.", "auto.", "Qed.", "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.", "Proof.", "auto.", "Qed.", "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.", "Proof.", "auto.", "Qed.", "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).", "Proof.", "auto.", "Qed.", "Lemma tech_mult_posZ : forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.", "Proof multZ_eq3.", "Lemma tech_mult_negZ : forall (x : nat) (y : Z), multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).", "Proof multZ_eq5.", "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.", "intros; elim x.", "simpl in |- *; reflexivity.", "intros; simpl in |- *; reflexivity.", "intros; elim n.", "simpl in |- *; symmetry in |- *.", "elim (addZ_opposite y I); intros.", "elim H0; intros; elim H2; intros; exact H4.", "intros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).", "elim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).", "elim (addZ_opposite y I); intros.", "elim H1; intros; elim H3; intros.", "rewrite H5.", "symmetry in |- *; exact (add_OZ (multZ (neg n0) y)).", "Qed.", "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).", "Proof.", "intros; elim x.", "simpl in |- *; reflexivity.", "intros; elim n.", "simpl in |- *; symmetry in |- *.", "elim (addZ_opposite y I); intros.", "elim H0; intros; elim H2; intros; exact H3.", "intros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).", "elim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).", "elim (addZ_opposite y I); intros.", "elim H1; intros; elim H3; intros; rewrite H4.", "rewrite (add_OZ (multZ (pos n0) y)); reflexivity.", "intros; reflexivity.", "Qed.", "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.", "intros; elim x.", "reflexivity.", "simple induction n.", "symmetry in |- *; exact (add_IZ_succZ y).", "intros y0 H; do 2 rewrite (tech_mult_posZ y0).", "rewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).", "elim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).", "elim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).", "rewrite (succ_addZ_r (multZ (pos y0) y) y).", "rewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).", "elim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).", "reflexivity.", "simple induction n.", "simpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).", "intros y0 H; do 2 rewrite (tech_mult_negZ y0).", "elim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).", "elim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).", "elim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).", "rewrite (opp_succZ y).", "rewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).", "rewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).", "elim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.", "Qed.", "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).", "intros; elim x.", "reflexivity.", "simple induction n.", "simpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).", "intros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).", "rewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).", "elim (pred_addZ_l (multZ (pos n0) (predZ y)) y).", "elim (addZ_commutativity y (multZ (pos n0) y)).", "elim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).", "elim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).", "rewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).", "reflexivity.", "simple induction n.", "simpl in |- *.", "replace (pos 0) with IZ; auto.", "rewrite (add_IZ_succZ (oppZ y)).", "exact (opp_predZ y).", "intros n0 H; do 2 rewrite (tech_mult_negZ n0).", "rewrite H; rewrite (opp_predZ y).", "elim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).", "elim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).", "elim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).", "rewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).", "rewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).", "elim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).", "reflexivity.", "Qed.", "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.", "simple destruct x.", "reflexivity.", "simple induction n.", "reflexivity.", "intros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.", "simple induction n.", "reflexivity.", "intros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.", "Qed.", "Lemma mult_IZ : forall x : Z, multZ x IZ = x.", "simple destruct x.", "reflexivity.", "simple induction n.", "reflexivity.", "intros y H; rewrite (tech_mult_posZ y IZ); rewrite H.", "rewrite (add_IZ_succZ (pos y)); reflexivity.", "simple induction n.", "reflexivity.", "intros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.", "rewrite (add_mIZ_predZ (neg y)); reflexivity.", "Qed.", "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.", "simple destruct x.", "reflexivity.", "simple induction n.", "reflexivity.", "intros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.", "rewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.", "simple induction n.", "reflexivity.", "intros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.", "elim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).", "rewrite (add_mIZ_predZ (neg y)); reflexivity.", "Qed.", "Theorem multZ_commutativity : commutativity Z multZ.", "unfold commutativity in |- *; intros; elim x.", "rewrite (mult_OZ y); unfold multZ in |- *; reflexivity.", "simple induction n.", "simpl in |- *; symmetry in |- *; exact (mult_IZ y).", "intros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H.", "elim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.", "intros; elim n.", "simpl in |- *; symmetry in |- *; exact (mult_mIZ y).", "intros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H.", "elim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.", "Qed.", "Theorem multZ_neutral : neutral Z IdZ multZ IZ.", "unfold neutral in |- *.", "split.", "exact I.", "intros.", "split.", "elim (multZ_commutativity IZ x); reflexivity.", "reflexivity.", "Qed.", "Theorem mult_add_distributivity : distributivity Z addZ multZ.", "unfold distributivity in |- *; intros; case x.", "split; reflexivity.", "simple induction n.", "split.", "rewrite addZ_eq2; rewrite multZ_eq2.", "rewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z).", "reflexivity.", "intros y0 H.", "elim H; intros; split.", "rewrite addZ_eq3; rewrite multZ_eq3.", "rewrite mult_succZ_l; rewrite H0.", "elim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).", "elim (addZ_commutativity z (multZ y z)).", "apply addZ_associativity.", "do 3 rewrite multZ_eq3.", "rewrite H1.", "apply (add_add Z addZ addZ_commutativity addZ_associativity).", "simple induction n.", "split.", "rewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z).", "exact (addZ_commutativity (multZ y z) (oppZ z)).", "rewrite multZ_eq4.", "apply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).", "intros y0 H.", "split.", "rewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).", "elim H; intros.", "rewrite H0.", "elim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).", "elim (addZ_commutativity (oppZ z) (multZ y z)).", "rewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).", "elim (tech_mult_negZ y0 z); reflexivity.", "rewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).", "rewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.", "elim (add_add Z addZ addZ_commutativity addZ_associativity (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) (oppZ z)).", "elim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).", "reflexivity.", "Qed.", "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).", "intros; case x.", "reflexivity.", "simple induction n.", "reflexivity.", "intros y0 H; do 2 rewrite (tech_mult_posZ y0).", "rewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) y) y I I).", "elim H; reflexivity.", "intros; elim n.", "reflexivity.", "intros y0 H; do 2 rewrite (tech_mult_negZ y0).", "rewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) y) (oppZ y) I I).", "elim H; reflexivity.", "Qed.", "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).", "simple destruct y.", "rewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.", "intros; elim (multZ_commutativity (pos n) (oppZ x)).", "elim (multZ_commutativity (pos n) x); elim n.", "reflexivity.", "intros y0 H; do 2 rewrite (tech_mult_posZ y0).", "rewrite H; symmetry in |- *.", "exact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) x) x I I).", "intros; elim (multZ_commutativity (neg n) (oppZ x)).", "elim (multZ_commutativity (neg n) x); elim n.", "reflexivity.", "intros y0 H; do 2 rewrite (tech_mult_negZ y0).", "rewrite H; symmetry in |- *.", "exact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) x) (oppZ x) I I).", "Qed.", "Lemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.", "Proof multZ_eq4.", "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).", "intros; elim n.", "reflexivity.", "intros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.", "rewrite (tech_add_pos_posZ (y * m + (y + m)) m).", "elim (technical_lemma y m); reflexivity.", "Qed.", "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).", "intros; elim n.", "reflexivity.", "intros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H; unfold oppZ in |- *.", "rewrite (tech_add_pos_posZ (y * m + (y + m)) m).", "elim (technical_lemma y m); reflexivity.", "Qed.", "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).", "intros; elim n.", "simpl in |- *; reflexivity.", "intros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.", "rewrite (tech_add_neg_negZ (y * m + (y + m)) m).", "elim (technical_lemma y m); reflexivity.", "Qed.", "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).", "intros; elim n.", "simpl in |- *; reflexivity.", "intros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *; rewrite H.", "rewrite (tech_add_neg_negZ (y * m + (y + m)) m).", "elim (technical_lemma y m); reflexivity.", "Qed.", "Theorem multZ_associativity : associativity Z multZ.", "unfold associativity in |- *; intros; elim x.", "reflexivity.", "simple induction n.", "unfold multZ in |- *; reflexivity.", "intros y0 H; do 2 rewrite (tech_mult_posZ y0).", "rewrite H; elim (mult_oppZ_l y z).", "elim (mult_add_distributivity (multZ (pos y0) y) y z); intros.", "elim H0.", "reflexivity.", "simple induction n.", "simpl in |- *; symmetry in |- *; exact (mult_oppZ_l y z).", "intros y0 H; do 2 rewrite (tech_mult_negZ y0).", "rewrite H; elim (mult_oppZ_l y z).", "elim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros.", "elim H0.", "reflexivity.", "Qed.", "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.", "unfold is_ring in |- *.", "split.", "exact addZ_commutativity.", "split.", "exact Z_group.", "split.", "unfold intern in |- *.", "intros.", "exact I.", "split.", "exact multZ_associativity.", "exact mult_add_distributivity.", "Qed.", "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.", "unfold is_unitary_commutative_ring in |- *.", "split.", "exact Z_ring.", "split.", "exact multZ_commutativity.", "exact multZ_neutral.", "Qed.", "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.", "intros n x; elim x.", "reflexivity.", "intros n0; rewrite (tech_mult_pos_posZ n n0); intros.", "absurd (pos (n * n0 + (n + n0)) = OZ).", "discriminate.", "exact H.", "intros n0; rewrite (tech_mult_pos_negZ n n0); intros.", "absurd (neg (n * n0 + (n + n0)) = OZ).", "discriminate.", "exact H.", "Qed.", "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.", "intros n x; elim x.", "reflexivity.", "intros n0; rewrite (tech_mult_neg_posZ n n0); intros.", "absurd (neg (n * n0 + (n + n0)) = OZ).", "discriminate.", "exact H.", "intros n0; rewrite (tech_mult_neg_negZ n n0); intros.", "absurd (pos (n * n0 + (n + n0)) = OZ).", "discriminate.", "exact H.", "Qed.", "Theorem integrityZ : integrity Z multZ OZ.", "unfold integrity in |- *; intros a b; elim a.", "intros; left; reflexivity.", "intros; right; apply (tech_integ_posZ n b); exact H.", "intros; right; apply (tech_integ_negZ n b); exact H.", "Qed.", "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).", "intros; elim m.", "elim multZ_neutral; intros; elim (H0 (pos n) I); intros.", "replace (pos 0) with IZ; auto.", "rewrite H1.", "elim (mult_commut 1 (S n)).", "rewrite (mult_neutr (S n)).", "unfold posOZ in |- *; reflexivity.", "intros y H; elim (multZ_commutativity (pos (S y)) (pos n)).", "rewrite (tech_mult_posZ y (pos n)); elim (multZ_commutativity (pos n) (pos y)).", "elim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).", "elim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).", "unfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).", "reflexivity.", "Qed.", "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).", "intros; elim (tech_mult_pos_succZ n m).", "simpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n); reflexivity.", "Qed.", "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).", "intros n0 n q r; elim q.", "elim r.", "intros; absurd (S n0 = 0).", "discriminate.", "exact H.", "intros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).", "simpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.", "elim r.", "intros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).", "rewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).", "elim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *; reflexivity.", "intros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).", "intros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).", "rewrite (tech_mult_pos_succZ2 n y0).", "rewrite (tech_add_pos_posZ (S n * y0 + n) y).", "elim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.", "reflexivity.", "Qed.", "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).", "intros n0 n q; elim q.", "simpl in |- *; intros; absurd (S n0 = 0).", "discriminate.", "exact H.", "intros y H; unfold negOZ in |- *.", "rewrite (tech_mult_pos_negZ n y); intros.", "simpl in H0; rewrite (eq_add_S _ _ H0).", "elim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).", "elim (plus_assoc n y (n * y)); reflexivity.", "Qed.", "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).", "intros; elim q.", "unfold posOZ in |- *; rewrite (mult_OZ (pos n)).", "cut (IZ = pos 0); intros.", "elim H.", "rewrite (mult_IZ (pos n)).", "elim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.", "rewrite H5; reflexivity.", "reflexivity.", "intros y H; unfold posOZ in |- *; elim (multZ_commutativity (pos (S y)) (pos n)).", "rewrite (tech_mult_posZ y (pos n)).", "rewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y) (pos n)) (pos n) I I).", "elim (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).", "elim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.", "rewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).", "elim (multZ_commutativity (pos y) (pos n)); reflexivity.", "Qed.", "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).", "intros n q r; elim r.", "unfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n)); elim (minus_n_O n).", "reflexivity.", "intros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry in |- *.", "exact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).", "Qed.", "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).", "intros.", "elim (tech_opp_pos_negZ q); intros; elim H1.", "rewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).", "rewrite (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r))) .", "rewrite (tech_div31 n q).", "elim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos n) (posOZ q)) (posOZ r) I I).", "elim (tech_div1 n0 n q r H); reflexivity.", "Qed.", "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).", "intros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.", "rewrite H0; intros; exact (tech_div1 n0 n q r H).", "cut (negOZ q = oppZ (posOZ q)); intros.", "rewrite H0.", "elim (tech_opp_pos_negZ n); intros; elim H1.", "apply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).", "elim q; reflexivity.", "Qed.", "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).", "intros; cut (posOZ q = oppZ (negOZ q)); intros.", "rewrite H0.", "elim (tech_opp_pos_negZ n); intros; elim H1.", "rewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).", "exact (tech_div2 n0 n q H).", "elim q; reflexivity.", "Qed.", "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).", "intros.", "elim (tech_opp_pos_negZ q); intros; elim H2.", "elim (tech_opp_pos_negZ n); intros; elim H3.", "rewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).", "apply (tech_div3 n0 n q r H H0).", "Qed.", "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.", "simple destruct x.", "intros; elim H; intros; elim H0; intros; elim H1.", "left; reflexivity.", "simple induction n.", "intros; left; reflexivity.", "intros y H H0; elim H0; intros; elim H1; intros.", "absurd (multZ (pos (S y)) x0 = IZ).", "elim x0.", "rewrite (mult_OZ (pos (S y))).", "discriminate.", "intros; rewrite (tech_mult_pos_posZ (S y) n0).", "elim (plus_comm (S y + n0) (S y * n0)).", "elim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.", "apply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).", "discriminate.", "intros; rewrite (tech_mult_pos_negZ (S y) n0).", "elim (plus_comm (S y + n0) (S y * n0)).", "elim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.", "exact H2.", "simple induction n.", "right; reflexivity.", "intros y H H0; elim H0; intros; elim H1; intros.", "absurd (multZ (neg (S y)) x0 = IZ).", "elim x0.", "rewrite (mult_OZ (neg (S y))).", "discriminate.", "intros; rewrite (tech_mult_neg_posZ (S y) n0).", "elim (plus_comm (S y + n0) (S y * n0)).", "elim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.", "intros; rewrite (tech_mult_neg_negZ (S y) n0).", "elim (plus_comm (S y + n0) (S y * n0)).", "elim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.", "apply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).", "discriminate.", "exact H2.", "Qed.", "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.", "simple destruct x.", "reflexivity.", "intros; exact (mult_IZ (pos n)).", "intros; exact (mult_mIZ (neg n)).", "Qed."], "theorems": [{"name": "multZ_eq1", "kind": "Lemma", "begin": 12, "end": 15}, {"name": "multZ_eq2", "kind": "Lemma", "begin": 16, "end": 19}, {"name": "multZ_eq3", "kind": "Lemma", "begin": 20, "end": 23}, {"name": "multZ_eq4", "kind": "Lemma", "begin": 24, "end": 27}, {"name": "multZ_eq5", "kind": "Lemma", "begin": 28, "end": 31}, {"name": "mult_succZ_l", "kind": "Lemma", "begin": 36, "end": 50}, {"name": "mult_predZ_l", "kind": "Lemma", "begin": 51, "end": 65}, {"name": "mult_succZ_r", "kind": "Lemma", "begin": 66, "end": 89}, {"name": "mult_predZ_r", "kind": "Lemma", "begin": 90, "end": 117}, {"name": "mult_OZ", "kind": "Lemma", "begin": 118, "end": 127}, {"name": "mult_IZ", "kind": "Lemma", "begin": 128, "end": 139}, {"name": "mult_mIZ", "kind": "Lemma", "begin": 140, "end": 152}, {"name": "multZ_commutativity", "kind": "Theorem", "begin": 153, "end": 164}, {"name": "multZ_neutral", "kind": "Theorem", "begin": 165, "end": 173}, {"name": "mult_add_distributivity", "kind": "Theorem", "begin": 174, "end": 212}, {"name": "mult_oppZ_r", "kind": "Lemma", "begin": 213, "end": 226}, {"name": "mult_oppZ_l", "kind": "Lemma", "begin": 227, "end": 242}, {"name": "tech_mult_pos_posZ", "kind": "Lemma", "begin": 245, "end": 251}, {"name": "tech_mult_neg_negZ", "kind": "Lemma", "begin": 252, "end": 258}, {"name": "tech_mult_pos_negZ", "kind": "Lemma", "begin": 259, "end": 265}, {"name": "tech_mult_neg_posZ", "kind": "Lemma", "begin": 266, "end": 272}, {"name": "multZ_associativity", "kind": "Theorem", "begin": 273, "end": 290}, {"name": "Z_ring", "kind": "Theorem", "begin": 291, "end": 304}, {"name": "Z_unitary_commutative_ring", "kind": "Theorem", "begin": 305, "end": 312}, {"name": "tech_integ_posZ", "kind": "Lemma", "begin": 313, "end": 324}, {"name": "tech_integ_negZ", "kind": "Lemma", "begin": 325, "end": 336}, {"name": "integrityZ", "kind": "Theorem", "begin": 337, "end": 342}, {"name": "tech_mult_pos_succZ", "kind": "Lemma", "begin": 343, "end": 357}, {"name": "tech_mult_pos_succZ2", "kind": "Lemma", "begin": 358, "end": 361}, {"name": "tech_div1", "kind": "Lemma", "begin": 362, "end": 380}, {"name": "tech_div2", "kind": "Lemma", "begin": 381, "end": 391}, {"name": "tech_div31", "kind": "Lemma", "begin": 392, "end": 408}, {"name": "tech_div32", "kind": "Lemma", "begin": 409, "end": 415}, {"name": "tech_div3", "kind": "Lemma", "begin": 416, "end": 424}, {"name": "tech_div4", "kind": "Lemma", "begin": 425, "end": 433}, {"name": "tech_div5", "kind": "Lemma", "begin": 434, "end": 441}, {"name": "tech_div6", "kind": "Lemma", "begin": 442, "end": 448}, {"name": "inversibleZ", "kind": "Lemma", "begin": 449, "end": 485}, {"name": "sgn_abs", "kind": "Lemma", "begin": 486, "end": 491}]}